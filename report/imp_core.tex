The implementation of a quantum computer requires several classes such as \emph{Complex, ComplexVector} and \emph{Matrix} to do mathematical calculations. These were written with clarity in mind to provide a simple to use interface instead of a highly optimized one. While the \emph{ComplexVector} is simply an array of \emph{Complex} objects in combination with vector methods, the \emph{Matrix} class forms a class hierarchy of two implementations: \emph{DenseMatrix} and \emph{SparseMatrix}. Both represent a generic square matrix, however a \emph{DenseMatrix} has a complex element for each index while the \emph{SparseMatrix} is memory efficient. Two implementations were considered due to the fact that many of the unitary matrices are not very complex, in fact sparse. A factory method was created to allow switching between representations depending on a condition: If the number of non-zero elements in the matrix is above half the elements in the matrix then a \emph{DenseMatrix} representation would be used.


The \emph{QRegister} class is the only implemented class in the \emph{Core} package, since it represents the single data structure in a quantum computer. A quantum register is simply a complex vector that contains all the amplitudes in each eigenstate, therefore classical data would be represented as sparse vector. However this was not implemented since most algorithms initially put a zero quantum register into a superposition of all states which would be a dense representation. We implemented the \emph{QRegister} class as having an intrinsic ability to be measured, multiple methods are concerned with this topic.

Multiple situations arose during the project when input data could be corrupted in some form. As such we implemented an extension to Java's native exceptions to handle specific quantum computer exceptions and inform the user of errors without crashing the program.