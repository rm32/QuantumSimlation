A classical computer that runs on electrical signals going around circuits has matured significantly since its inception and now forms the backbone of society. However, society has grown as well, along with its needs for more and more computing power. Transistors become smaller and armies of cores work in parallel to keep up with current demands. This trend can still continue for a while and it should work, but perhaps some lateral thinking is needed for the next step. That new idea could be a whole different approach: a quantum computer.

At the start of the 1980's Richard Feynman introduced his idea of a universal quantum computer. He realized that a quantum-mechanical system cannot really be simulated by a classical computer, only with an exponential slowdown. This would mean that a quantum computer can simulate a quantum mechanical system far more efficiently than a classical computer \cite{feynman1982}.

As the years went by, a number of algorithms suitable for a quantum computing machine were created. In 1992 Deutsch and Jozsa discovered one of the first algorithms that run exponentially faster than the classical version. Two years later in 1994 Shor's quantum algorithm for factoring numbers was born. Afterwards Grover found an unsorted database search algorithm. All these showed an exponential speed increase over their classical equivalents, so clearly there is some merit to this idea. 

The goal of this project was to explore the theoretical framework of quantum computing. This was achieved by programming a simulation of a quantum computer in Java. After all, you can only be sure that you understand something if you can teach it to a computer. The project code contains basic mathematical tools and a universal set of gates plus some more for convenience; these are used to construct a circuit for Grover's, Shor's and Deutsch-Jozsa algorithms as a proof of concept.

This report covers the theory, principles of quantum computing and the building blocks of the algorithms. This is followed by an explanation of the overall design and implementation details of the core components, operators and algorithms. We further discuss the main results of the project, including successes and points of potential improvement.
