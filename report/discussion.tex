The finished code contains the basic mathematical tools of quantum computing and a large set of gates that are needed to build algorithms. These components have been used to implement Grover's, Shor's and Deutsch-Jozsa algorithms, thus proving the concept of a quantum computer. The algorithm frameworks and gates allow implementations of further algorithms and extensions to the simulation. The resulting packages are of significant value to test out ideas in theory before a complicated and expensive physical quantum system is built.

The things we did well were we adhering to good coding practices, i.e. a carefully planned out set of abstract classes. The use of version control system, \emph{GIT} in our case, allowed for efficient work. This and general organisational effort, like delegation of responsibilities, meant that there were almost no overlapping efforts and the code base quickly grew as we worked in parallel.

While an implementation of a quantum computer has been achieved, it is still rather limited in speed and memory capacity. As more qubits are added to the register, the memory and computation requirements grow exponentially. This is expected, though, as it is a simulation of a system in an incompatible environment, a quantum computer simulated on a classical computer, defeats the purpose. These difficulties arise because it is impossible to use the benefits that come with computations using particles and their quantum effects. Nature has infinite clock cycles.
Other difficulties were technical issues with the version control system which would frequently prohibit synchronisation of code possibly due to insufficient support from the IDE \emph{Netbeans}. There were also some naming convention inconsistencies that caused time loss as they had to be corrected in order to have coherent code.

The project was completed with a great deal of success but there is always room for improvement. For example, in the interest of completeness, more gates could have benefited from bit twiddling or otherwise more efficient implementations than matrix manipulation. The universal set, \emph{CNot} and \emph{Hadamard}, both have implementations so it is not a pressing issue.
The overall design is slightly circumvented by having a measure method hidden in the \emph{QRegister} class. The more consistent approach would be to have a separate measurement gate in the set of universal gates.
Another thing we could have implemented is a more intelligent matrix framework. For example a matrix that stores values in a set and then points to non-zero values in the actual matrix. This would allow matrices which do not have enough non-zero values to be sparse but enough equivalent elements to be represented well.
The naming convention inconsistencies could have been resolved by producing a sample class with every possible type of code in it. This would serve as a reference while writing code.

